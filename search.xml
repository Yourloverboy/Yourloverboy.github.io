<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shell编程函数的定义和使用]]></title>
    <url>%2F2018%2F12%2F22%2FShell%E7%BC%96%E7%A8%8B%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[说到函数的声明和调用，学过c语言、java等其他编程语言的人想必都不陌生，也发现其实都是大同小异。今天我们来学习一下shell函数的声明和调用是什么样的，以及哪些是我们需要注意的。 语法格式1234function 函数名()&#123; 若干条执行语句 return int&#125; 可以function 函数名()定义，也可以直接函数名()定义，不加‘function’关键字。 不需要任何参数。 参数返回：可以显示加renturn n(n的值为0~255之间)；或者echo（标准输出）传递给主程序变量。 函数的调用Shell函数的调用和传参与其他语言有不同之处。 函数必须在定义之后才能调用，不然报错。因为shell脚本是一种解释性语言，也就是读到一行执行一行，当你在定义前调用时根本没有这个函数。这个和编译性语言不同。 Shell函数的调用分两种： 在脚本使用之前定义1234567#!/bin/bash#filename: fun.shfun() &#123; echo "我定义的一个函数"&#125;fun #直接写上函数名调用，不需要()执行符 输出结果：我定义的一个函数 把函数定义在一个独立的文件使用点号(.)命令来引用它比如我有两个shell脚本并且在同一目录下，名字分别为fun1.sh和fun2.sh。 12345#!/bin/bash#filename: fun1.shfun() &#123; echo "我定义的一个函数"&#125; 1234#！/bin/bash#filename: fun2.sh. ./fun1.sh #点号之间有一个空格fun 输出结果：我定义的一个函数 同时，我们也可以在终端中通过点好(.)命令来引用我们定义的函数。 fun1.sh文件内容 直接在终端中调用这个函数（报错！not found） 使用点号(.)引用函数（执行成功） 首先我们要知道shell脚本的执行是在子进程下执行的，而在子进程下我们没有这个函数命令，所以报错not found找不到。 而加上点号的意思就是在当前进程中执行引用这个函数命令。也就是可以成功执行了。 需要传递参数时12345678#!/bin/bash#filename: fun.shfun() &#123; echo -e "我定义的一个函数\n$num" #-e用来识别转义字符&#125;num=666fun num #在调用函数后面空格隔开，写上要传递的参数，多个参数传递时也是参数间空格隔开 执行输出：我定义的一个函数 ​ 666 举个例子123456789101112#!/bin/bash#filename: sum.shsum() &#123; var1=$1 var2=$2 var=$(($1 + $2)) #$1是第一个变量，$2是第二个变量 return $var&#125;read num1 num2sum num1 num2echo "这两个数的和是$?" #$?是一个系统变量，里面保存的是上一个函数的返回值 假如我们输入的两个数是10和20（也就是num1=10，num2=20） 执行输出：这两个数的和是30 又假如我们输入的两个数是255和1（也就是num1=255，num2=1） 执行输出：这两个数的和是0 为什么255+1会返回一个0，因为我们前面说过了return只能返回0~255之间的数，关于为什么返回的是0而不是别的数我们后面会讲。 改进例子123456789101112#!/bin/bash#filename: sum.shsum() &#123; var1=$1 var2=$2 var=$(($1 + $2)) echo $var #这里的return改为了echo&#125;read num1 num2sum=$(sum num1 num2) #这里定义了一个变量sum来接受函数sum传递的值echo "这两个数的和是$sum" #这里将$?改为了我们定义的变量$sum 假如我们输入的两个数是255和1（也就是num1=255，num2=1） 执行输出：这两个数的和是256 这样好像就没毛病了，没有返回值的范围限制，结果也是正确的。但是真的是这样吗？如果我们要给我们的函数输出一些修饰语句呢？看下面。 12 假如我们输入的两个数是255和1（也就是num1=255，num2=1） 理想输出：这是一个求和函数 ​ sum=256 但是我们想的真的和计算机一样吗，看下面。 实际输出：sum=这是一个求和函数 ​ 256 为什么会这样？echo不是一个返回值，我们前面说过是echo（标准输出）是将传递给主程序的变量。也就是如果我们在主程序中设置了一个变量并且函数是用echo（标准输出）来传递值给主程序变量时，会将所有echo（标准输出）的语句都传递给这个变量，也就产生了上面那种输出结果。 使用return还是echo在上面的学习中，我们知道了return的返回范围只能在0~255之间，并且是被保存在了一个系统变量$?里面（后面会列出一些比较常见的一些系统变量）； 而使用echo没有数值大小的限制和变量类型的限制，是将echo(标准输出)的东西传递给主程序的变量，多个echo会造成意料之外的一些情况。 我们知道了上面这些，就可以在编写我们自己的函数时合理选择是使用return或者是echo了。 一些常见的系统变量 ​ $? 表示函数的返回值； ​ $n表示传递给脚本或者函数的第几个参数（n是一个数字）； ​ $*表示传递给脚本或函数的所有参数； ​ $#表示传递给脚本或者函数的个数； ​ $0表示当前执行的进程名； ​ $$表示当前进程的进程号； 知道这些系统变量之后，我们可以做一个任意个数的四则运算。我们可以用for循环来遍历，将$#作为条件，$n就是第几个参数这样作四则运算。 Shell退出状态码整理shell中运行的每个命令都使用退出状态码（exit status）来告诉shell它完成了处理。退出状态码是一个0~255之间的整数值，在命令结束时由命令传回shell。 1、查看推出状态码​ Linux提供了$?专属变量保存上一个执行的命令的退出状态码。你可以在你运行一个命令之后查看（echo $?）。​ 几个典型的退出状态码及其意义：​ 0—————-命令运行成功​ 1—————-通知未知错误​ 2—————-误用shell命令​ 126————-命令不可执行​ 127————-没有找到命令​ 128————-无效退出参数​ 128+x———–linux信号x的严重错误​ 130————–命令通过Ctrl+C终止​ 255————–退出状态码越界 2、exit命令 用于shell 脚本中指定退出状态码。 也就是自己显示的设置return返回的值​ 退出状态码的最大只能是255。若其大于255，则返回模除（%）256后的余数。]]></content>
      <tags>
        <tag>Shell编程</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js鼠标点击页面效果]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%8E%9F%E7%94%9Fjs%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[在进入这个网站的时候我们点击的时候就已经看到了一个点击页面弹出字或者表情的一个效果。现在我们使用原生js来实现一下。 我将代码放在了下方，并且一些内容我会在代码里面注释出来： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788"use strict"; //ES5严格模式，可不加onload = function() &#123; var click_cnt = 0; //统计点击次数 //获取html和doay标签元素 var $html = document.getElementsByTagName("html")[0]; var $body = document.getElementsByTagName("body")[0]; //绑定点击事件 $html.onclick = function(e) &#123; //创建一个b标签 var $elem = document.createElement("b"); //给b标签加上css样式 $elem.style.color = "#E94F06"; $elem.style.zIndex = 99999; $elem.style.position = "absolute"; $elem.style.select = "none"; //获取鼠标点击的点 var x = e.pageX; var y = e.pageY; //设置效果在鼠标点击的位置 $elem.style.left = (x - 10) + "px"; $elem.style.top = (y - 20) + "px"; //根据点击次数出现的文字或者表情 switch (++click_cnt) &#123; case 10: $elem.innerText = "OωO"; break; case 20: $elem.innerText = "(๑•́ ∀ •̀๑)"; break; case 30: $elem.innerText = "(๑•́ ₃ •̀๑)"; break; case 40: $elem.innerText = "(๑•̀_•́๑)"; break; case 50: $elem.innerText = "(๑˙ー˙๑)"; break; case 60: $elem.innerText = "(╯°口°)╯(┴—┴"; break; case 70: $elem.innerText = "૮( ᵒ̌皿ᵒ̌ )ა"; break; case 80: $elem.innerText = "╮(｡&gt;口&lt;｡)╭"; break; case 90: $elem.innerText = "( ง ᵒ̌皿ᵒ̌)ง⁼³₌₃"; break; case 100: case 101: case 102: case 103: case 104: case 105: $elem.innerText = "(ꐦ°᷄д°᷅)"; break; default: $elem.innerText = "你点我~"; break; &#125; //设置出现文字的随机大小 $elem.style.fontSize = Math.random() * 10 + 8 + "px"; //设置文字的运动效果，利用时间戳 var increase = 0; var anim; setTimeout(function() &#123; anim = setInterval(function() &#123; if (++increase == 150) &#123; clearInterval(anim); $body.removeChild($elem); &#125; $elem.style.top = y - 20 - increase + "px"; $elem.style.opacity = (150 - increase) / 120; &#125;, 8); &#125;, 70); $body.appendChild($elem); &#125;;&#125;; 上面就是完整的一个鼠标点击页面效果。]]></content>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下简单使用make、makefile]]></title>
    <url>%2F2018%2F11%2F18%2Fmakefile%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[make是什么？make的功能：make是一个解释makefile中指令的命令工具。他可以简化编译过程里面所下达的指令，当执行make时，make会在当前的目录下搜寻makefile（Makefile）这个文本文件（可以理解为编译的配置文件），执行对应的操作。make会自动的判别原始码是否经过变动了，而自动更新执行档。 原理：当make指令第一次执行时，它会扫描makefile找到目标以及其依赖。看这些依赖是否是目标，如果是那就继续为这些依赖扫描makefile找到它的依赖关系，建立它，并执行其方法。如果不是直接就可以建立关系，编译它们。 为什么要使用make？假设，现在一个项目里面包含了100个程序文件，如果要对这个项目进行编译，那么光是编译指令就是100条。如果要重新进行编译，那么就得像之前全部重来一次。这么低效的方法我们程序员肯定是忍不了，不符合我们程序员的作风。所以，用make来进行操作，间接的调用gcc岂不是很便捷？如果我们更动过某些源文件，make也可以主动的判断哪一个源文件与相关的目标文件有更新过，并且仅更新该目标文件。这样不但减少了重新编译所需要的时间，使用起来也更加方便。 gcc编译器和make命令工具安装在Linux终端中执行 安装gcc编译器： 1sudo apt install gcc 安装make命令工具： 1sudo apt install make 两个一路等待下载执行完成。 makefile的规则语法12目标（target）: 目标文件1 目标文件2 gcc -o 预建立的执行文件 目标文件1 目标文件2 注意：建立执行语法（也就是gcc那条语句）必须以tab键开头，不可以使用空格代替。 目标（target）就是我们想要建立的信息，而目标文件就是具有相关性的object files。 语法： 在makefile当中的#代表批注； tab键需要在命令行（例如gcc这个编译程序指令）的开头第一个字符； 目标（target）与相关目标文件之间需要用 : (分号)隔开； makefile使用举例说明我们要编译main.c、test1.h、test2.h、test3.h生成可执行程序TEST。 我们可以直接使用gcc这样写： 1gcc -o TEST main.c test1.h test2.h test3.h 但是就像上面说的，我们之后发现了test2.c里面的内容写错了，改好之后要重新编译，我们接着输入上面的命令进行编译。但是如果我们一个项目有很多文件时，就很麻烦了。我们可以写个makefile简化方便执行。 创建一个makefile或者Makefile文件（必须是），因为make指令在编译时它会查找以下文件是否有makefile或者Mkefile： 1touch makefile vi命令进入makefile： 1vi makefile 修改makefile文件如下： 12TEST： main.c test1.h test2.h test3.h gcc -o TEST main.c test1.h test2.h test3.h 我的main.c、test1.h、test2.h、test3.h内容如下： 一切准备完成之后，我们直接执行make即可编译文件： 1make 编译完成后，我们看到目录下产生了TEST文件，接下来执行它试试看： 1./TEST 如果不想让编译规则显示在屏幕上，只要在编译规则前面加个@。 如果现在再对文件编译一次会发生什么呢？可以试一下。 如果修改了其中一个文件再编译一下又会发生什么？ 现在我们在makefile里面定义一个clean，用来执行rm的操作： 1234TEST： main.c test1.h test2.h test3.h gcc -o TEST main.c test1.h test2.h test3.hclean: rm -f TEST 执行： 1make clean 这里调用了clean，就把之前编译完成的TEST文件删除了。 像我们有多个文件需要处理，可以在makefile里面定义一个变量： 12345OBJS = main.c test1.h test2.h test3.hTEST： $(OBJS) gcc -o TEST $(OBJS)clean: rm -f TEST 结果和上面写法一样，如果我们执行make clean TEST，先调用clean清除，然后调用了TEST编译。 注意： 变量名左边不可以加tab键； 变量与变量内容用 = （等号）隔开； 变量名最好大写，为了编码风格； 运用变量时，以$(变量名)或者${变量名}使用；]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
