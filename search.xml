<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[原生js鼠标点击页面效果]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%8E%9F%E7%94%9Fjs%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux下简单使用make、makefile]]></title>
    <url>%2F2018%2F11%2F18%2Fmakefile%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[make是什么？make的功能：make是一个解释makefile中指令的命令工具。他可以简化编译过程里面所下达的指令，当执行make时，make会在当前的目录下搜寻makefile（Makefile）这个文本文件（可以理解为编译的配置文件），执行对应的操作。make会自动的判别原始码是否经过变动了，而自动更新执行档。 原理：当make指令第一次执行时，它会扫描makefile找到目标以及其依赖。看这些依赖是否是目标，如果是那就继续为这些依赖扫描makefile找到它的依赖关系，建立它，并执行其方法。如果不是直接就可以建立关系，编译它们。 为什么要使用make？假设，现在一个项目里面包含了100个程序文件，如果要对这个项目进行编译，那么光是编译指令就是100条。如果要重新进行编译，那么就得像之前全部重来一次。这么低效的方法我们程序员肯定是忍不了，不符合我们程序员的作风。所以，用make来进行操作，间接的调用gcc岂不是很便捷？如果我们更动过某些源文件，make也可以主动的判断哪一个源文件与相关的目标文件有更新过，并且仅更新该目标文件。这样不但减少了重新编译所需要的时间，使用起来也更加方便。 gcc编译器和make命令工具安装在Linux终端中执行 安装gcc编译器： 1sudo apt install gcc 安装make命令工具： 1sudo apt install make 两个一路等待下载执行完成。 makefile的规则语法12目标（target）: 目标文件1 目标文件2 gcc -o 预建立的执行文件 目标文件1 目标文件2 注意：建立执行语法（也就是gcc那条语句）必须以tab键开头，不可以使用空格代替。 目标（target）就是我们想要建立的信息，而目标文件就是具有相关性的object files。 语法： 在makefile当中的#代表批注； tab键需要在命令行（例如gcc这个编译程序指令）的开头第一个字符； 目标（target）与相关目标文件之间需要用 : (分号)隔开； makefile使用举例说明我们要编译main.c、test1.h、test2.h、test3.h生成可执行程序TEST。 我们可以直接使用gcc这样写： 1gcc -o TEST main.c test1.h test2.h test3.h 但是就像上面说的，我们之后发现了test2.c里面的内容写错了，改好之后要重新编译，我们接着输入上面的命令进行编译。但是如果我们一个项目有很多文件时，就很麻烦了。我们可以写个makefile简化方便执行。 创建一个makefile或者Makefile文件（必须是），因为make指令在编译时它会查找以下文件是否有makefile或者Mkefile： 1touch makefile vi命令进入makefile： 1vi makefile 修改makefile文件如下： 12TEST： main.c test1.h test2.h test3.h gcc -o TEST main.c test1.h test2.h test3.h 我的main.c、test1.h、test2.h、test3.h内容如下： 一切准备完成之后，我们直接执行make即可编译文件： 1make 编译完成后，我们看到目录下产生了TEST文件，接下来执行它试试看： 1./TEST 如果不想让编译规则显示在屏幕上，只要在编译规则前面加个@。 如果现在再对文件编译一次会发生什么呢？可以试一下。 如果修改了其中一个文件再编译一下又会发生什么？ 现在我们在makefile里面定义一个clean，用来执行rm的操作： 1234TEST： main.c test1.h test2.h test3.h gcc -o TEST main.c test1.h test2.h test3.hclean: rm -f TEST 执行： 1make clean 这里调用了clean，就把之前编译完成的TEST文件删除了。 像我们有多个文件需要处理，可以在makefile里面定义一个变量： 12345OBJS = main.c test1.h test2.h test3.hTEST： $(OBJS) gcc -o TEST $(OBJS)clean: rm -f TEST 结果和上面写法一样，如果我们执行make clean TEST，先调用clean清除，然后调用了TEST编译。 注意： 变量名左边不可以加tab键； 变量与变量内容用 = （等号）隔开； 变量名最好大写，为了编码风格； 运用变量时，以$(变量名)或者${变量名}使用；]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
