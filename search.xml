<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js按位运算符]]></title>
    <url>%2F2018%2F12%2F23%2Fjs%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[位运算可以对由数字表示的二进制数进行更底层的按位运算。JavaScript中有7种位运算符，分别为按位与（&amp;），按位或（ | ），按位异或（^），按位非（~），左移位（&lt;&lt;）,带符号右移位（&gt;&gt;），无符号右移位（&gt;&gt;&gt;）。 按位与（&amp;）&amp;是一个二元运算符（有两个操作数），&amp;对它的整型操作数逐位执行布尔与操作（将十进制转换成二进制），只有两个操作数相对应的位都是1，结果才是1。有一个为0就是0。 1&amp;3的结果是1 那么它是怎么运算的呢 1的二进制表示是 0 0 0 0 0 0 0 1 3的二进制表示是 0 0 0 0 0 0 1 1 根据&amp;运算符的规则，得到的结果就是 0 0 0 0 0 0 0 1，转换成十进制表示就是1。 按位或（ | ） | 运算符和&amp;运算符的区别就在于只要两个操作数对应的位有一个为1那么结果就是1。 1|3的结果是3 1的二进制表示是 0 0 0 0 0 0 0 1 3的二进制表示是 0 0 0 0 0 0 1 1 根据 | 运算符的规则，得到的结果就是 0 0 0 0 0 0 1 1，转换成十进制表示就是3。 按位异或（^）^运算符是两个操作数对应的位只有一个为1结果才是1，两个为0结果是0，这里注意两个都为1结果就是0 1^3的结果是2 1的二进制表示是 0 0 0 0 0 0 0 1 3的二进制表示是 0 0 0 0 0 0 1 1 根据^运算符的规则，得到的结果就是 0 0 0 0 0 0 1 0，转换成十进制表示就是2。 按位非（~）~运算符是一元运算符（一个操作数），将整型操作数进行逐位进行布尔操作（将十进制数转换成二进制），之后逐位求反（1变为0，0变为1）。 之后会有一篇文章专门讲原码、反码和补码。 ~1(对1的取反)结果是-2 1转换成二进制表示是 0 0 0 0 0 0 0 1 计算补码： 0 0 0 0 0 0 0 1 按位取反： 1 1 1 1 1 1 1 0 转为原码（符号位不变）： ​ 末位减1： 1 1 1 1 1 1 0 1 ​ 按位取反： 1 0 0 0 0 0 1 0 ​ 末位加一： 1 0 0 0 0 0 1 0 转换成十进制就是-2。 左移位（&lt;&lt;）&lt;&lt;运算符使指定值的二进制所有位都左移规定的次数，对于其移动规则只需记住丢弃最高位，0补最低位即按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。 1&lt;&lt;2结果是4 1转换成二进制表示是 0 0 0 0 0 0 1 向左移2位得到： 0 0 0 0 0 1 0 0 转换成十进制就是4。 将一个值左移1位就相当于这个值乘以2，左移两位就是乘以4，以此类推。 带符号右移位（&gt;&gt;）>&gt;运算符使指定值的二进制所有位都右移规定的次数，对于其移动规则只需记住符号位不变，左边补上符号位即按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1。 1&gt;&gt;2结果是0 7&gt;&gt;2结果是 7转换成二进制表示是 0 0 0 0 0 1 1 1 向右移2位得到 0 0 0 0 0 0 0 1 转换成十进制就是1。 -7&gt;&gt;2结果是-2 -7转换成二进制表示是 1 0 0 0 0 1 1 1 计算补码(符号位不变)： ​ 按位取反：1 1 1 1 1 0 0 0 ​ 末位加1： 1 1 1 1 1 0 0 1 右移两位（高位补1）： 1 1 1 1 1 1 1 0 计算原码（符号位不变）： ​ 按位取反： 1 0 0 0 0 0 0 1 ​ 末位加1： 1 0 0 0 0 0 1 0 转换成十进制就是-2。 将一个值右移1位就相当于这个数除以2（忽略小数点部分），右移2位就相当于除以4，依次类推。 无符号右移位（&gt;&gt;&gt;）>&gt;&gt;运算符忽略了符号位扩展，0补最高位(与原来数的符号无关)，但是只是对32位和64位的值有意义。 -1&gt;&gt;2结果是-1 但是-1&gt;&gt;&gt;2结果是 -1的二进制是 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 计算补码： ​ 按位取反： 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 ​ 末位加1：1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 右移2位，高位补0： 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 转换成十进制就是1073741823。 位运算在js中的妙用使用&amp;运算符判断一个数的奇偶奇数&amp;1 结果是 1 偶数&amp;1 结果是 0 1为奇数，0为偶数。那么3&amp;1=1，4&amp;1=0。 使用^运算符完成数值的交换a=2 b=3 a^=b b^=a a^=b 结果a=3，b=2。]]></content>
      <tags>
        <tag>js</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程函数的定义和使用]]></title>
    <url>%2F2018%2F12%2F22%2FShell%E7%BC%96%E7%A8%8B%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[说到函数的声明和调用，学过c语言、java等其他编程语言的人想必都不陌生，也发现其实都是大同小异。今天我们来学习一下shell函数的声明和调用是什么样的，以及哪些是我们需要注意的。 语法格式1234function 函数名()&#123; 若干条执行语句 return int&#125; 可以function 函数名()定义，也可以直接函数名()定义，不加‘function’关键字。 不需要任何参数。 参数返回：可以显示加renturn n(n的值为0~255之间)；或者echo（标准输出）传递给主程序变量。 函数的调用Shell函数的调用和传参与其他语言有不同之处。 函数必须在定义之后才能调用，不然报错。因为shell脚本是一种解释性语言，也就是读到一行执行一行，当你在定义前调用时根本没有这个函数。这个和编译性语言不同。 Shell函数的调用分两种： 在脚本使用之前定义1234567#!/bin/bash#filename: fun.shfun() &#123; echo "我定义的一个函数"&#125;fun #直接写上函数名调用，不需要()执行符 输出结果：我定义的一个函数 把函数定义在一个独立的文件使用点号(.)命令来引用它比如我有两个shell脚本并且在同一目录下，名字分别为fun1.sh和fun2.sh。 12345#!/bin/bash#filename: fun1.shfun() &#123; echo "我定义的一个函数"&#125; 1234#！/bin/bash#filename: fun2.sh. ./fun1.sh #点号之间有一个空格fun 输出结果：我定义的一个函数 同时，我们也可以在终端中通过点好(.)命令来引用我们定义的函数。 fun1.sh文件内容 直接在终端中调用这个函数（报错！not found） 使用点号(.)引用函数（执行成功） 首先我们要知道shell脚本的执行是在子进程下执行的，而在子进程下我们没有这个函数命令，所以报错not found找不到。 而加上点号的意思就是在当前进程中执行引用这个函数命令。也就是可以成功执行了。 需要传递参数时12345678#!/bin/bash#filename: fun.shfun() &#123; echo -e "我定义的一个函数\n$num" #-e用来识别转义字符&#125;num=666fun num #在调用函数后面空格隔开，写上要传递的参数，多个参数传递时也是参数间空格隔开 执行输出：我定义的一个函数 ​ 666 举个例子123456789101112#!/bin/bash#filename: sum.shsum() &#123; var1=$1 var2=$2 var=$(($1 + $2)) #$1是第一个变量，$2是第二个变量 return $var&#125;read num1 num2sum num1 num2echo "这两个数的和是$?" #$?是一个系统变量，里面保存的是上一个函数的返回值 假如我们输入的两个数是10和20（也就是num1=10，num2=20） 执行输出：这两个数的和是30 又假如我们输入的两个数是255和1（也就是num1=255，num2=1） 执行输出：这两个数的和是0 为什么255+1会返回一个0，因为我们前面说过了return只能返回0~255之间的数，关于为什么返回的是0而不是别的数我们后面会讲。 改进例子123456789101112#!/bin/bash#filename: sum.shsum() &#123; var1=$1 var2=$2 var=$(($1 + $2)) echo $var #这里的return改为了echo&#125;read num1 num2sum=$(sum num1 num2) #这里定义了一个变量sum来接受函数sum传递的值echo "这两个数的和是$sum" #这里将$?改为了我们定义的变量$sum 假如我们输入的两个数是255和1（也就是num1=255，num2=1） 执行输出：这两个数的和是256 这样好像就没毛病了，没有返回值的范围限制，结果也是正确的。但是真的是这样吗？如果我们要给我们的函数输出一些修饰语句呢？看下面。 12 假如我们输入的两个数是255和1（也就是num1=255，num2=1） 理想输出：这是一个求和函数 ​ sum=256 但是我们想的真的和计算机一样吗，看下面。 实际输出：sum=这是一个求和函数 ​ 256 为什么会这样？echo不是一个返回值，我们前面说过是echo（标准输出）是将传递给主程序的变量。也就是如果我们在主程序中设置了一个变量并且函数是用echo（标准输出）来传递值给主程序变量时，会将所有echo（标准输出）的语句都传递给这个变量，也就产生了上面那种输出结果。 使用return还是echo在上面的学习中，我们知道了return的返回范围只能在0~255之间，并且是被保存在了一个系统变量$?里面（后面会列出一些比较常见的一些系统变量）； 而使用echo没有数值大小的限制和变量类型的限制，是将echo(标准输出)的东西传递给主程序的变量，多个echo会造成意料之外的一些情况。 我们知道了上面这些，就可以在编写我们自己的函数时合理选择是使用return或者是echo了。 一些常见的系统变量 ​ $? 表示函数的返回值； ​ $n表示传递给脚本或者函数的第几个参数（n是一个数字）； ​ $*表示传递给脚本或函数的所有参数； ​ $#表示传递给脚本或者函数的个数； ​ $0表示当前执行的进程名； ​ $$表示当前进程的进程号； 知道这些系统变量之后，我们可以做一个任意个数的四则运算。我们可以用for循环来遍历，将$#作为条件，$n就是第几个参数这样作四则运算。 Shell退出状态码整理shell中运行的每个命令都使用退出状态码（exit status）来告诉shell它完成了处理。退出状态码是一个0~255之间的整数值，在命令结束时由命令传回shell。 1、查看推出状态码​ Linux提供了$?专属变量保存上一个执行的命令的退出状态码。你可以在你运行一个命令之后查看（echo $?）。​ 几个典型的退出状态码及其意义：​ 0—————-命令运行成功​ 1—————-通知未知错误​ 2—————-误用shell命令​ 126————-命令不可执行​ 127————-没有找到命令​ 128————-无效退出参数​ 128+x———–linux信号x的严重错误​ 130————–命令通过Ctrl+C终止​ 255————–退出状态码越界 2、exit命令 用于shell 脚本中指定退出状态码。 也就是自己显示的设置return返回的值​ 退出状态码的最大只能是255。若其大于255，则返回模除（%）256后的余数。]]></content>
      <tags>
        <tag>Shell编程</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js鼠标点击页面效果]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%8E%9F%E7%94%9Fjs%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[在进入这个网站的时候我们点击的时候就已经看到了一个点击页面弹出字或者表情的一个效果。现在我们使用原生js来实现一下。 我将代码放在了下方，并且一些内容我会在代码里面注释出来： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788"use strict"; //ES5严格模式，可不加onload = function() &#123; var click_cnt = 0; //统计点击次数 //获取html和doay标签元素 var $html = document.getElementsByTagName("html")[0]; var $body = document.getElementsByTagName("body")[0]; //绑定点击事件 $html.onclick = function(e) &#123; //创建一个b标签 var $elem = document.createElement("b"); //给b标签加上css样式 $elem.style.color = "#E94F06"; $elem.style.zIndex = 99999; $elem.style.position = "absolute"; $elem.style.select = "none"; //获取鼠标点击的点 var x = e.pageX; var y = e.pageY; //设置效果在鼠标点击的位置 $elem.style.left = (x - 10) + "px"; $elem.style.top = (y - 20) + "px"; //根据点击次数出现的文字或者表情 switch (++click_cnt) &#123; case 10: $elem.innerText = "OωO"; break; case 20: $elem.innerText = "(๑•́ ∀ •̀๑)"; break; case 30: $elem.innerText = "(๑•́ ₃ •̀๑)"; break; case 40: $elem.innerText = "(๑•̀_•́๑)"; break; case 50: $elem.innerText = "(๑˙ー˙๑)"; break; case 60: $elem.innerText = "(╯°口°)╯(┴—┴"; break; case 70: $elem.innerText = "૮( ᵒ̌皿ᵒ̌ )ა"; break; case 80: $elem.innerText = "╮(｡&gt;口&lt;｡)╭"; break; case 90: $elem.innerText = "( ง ᵒ̌皿ᵒ̌)ง⁼³₌₃"; break; case 100: case 101: case 102: case 103: case 104: case 105: $elem.innerText = "(ꐦ°᷄д°᷅)"; break; default: $elem.innerText = "你点我~"; break; &#125; //设置出现文字的随机大小 $elem.style.fontSize = Math.random() * 10 + 8 + "px"; //设置文字的运动效果，利用时间戳 var increase = 0; var anim; setTimeout(function() &#123; anim = setInterval(function() &#123; if (++increase == 150) &#123; clearInterval(anim); $body.removeChild($elem); &#125; $elem.style.top = y - 20 - increase + "px"; $elem.style.opacity = (150 - increase) / 120; &#125;, 8); &#125;, 70); $body.appendChild($elem); &#125;;&#125;; 上面就是完整的一个鼠标点击页面效果。]]></content>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下简单使用make、makefile]]></title>
    <url>%2F2018%2F11%2F18%2Fmakefile%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[make是什么？make的功能：make是一个解释makefile中指令的命令工具。他可以简化编译过程里面所下达的指令，当执行make时，make会在当前的目录下搜寻makefile（Makefile）这个文本文件（可以理解为编译的配置文件），执行对应的操作。make会自动的判别原始码是否经过变动了，而自动更新执行档。 原理：当make指令第一次执行时，它会扫描makefile找到目标以及其依赖。看这些依赖是否是目标，如果是那就继续为这些依赖扫描makefile找到它的依赖关系，建立它，并执行其方法。如果不是直接就可以建立关系，编译它们。 为什么要使用make？假设，现在一个项目里面包含了100个程序文件，如果要对这个项目进行编译，那么光是编译指令就是100条。如果要重新进行编译，那么就得像之前全部重来一次。这么低效的方法我们程序员肯定是忍不了，不符合我们程序员的作风。所以，用make来进行操作，间接的调用gcc岂不是很便捷？如果我们更动过某些源文件，make也可以主动的判断哪一个源文件与相关的目标文件有更新过，并且仅更新该目标文件。这样不但减少了重新编译所需要的时间，使用起来也更加方便。 gcc编译器和make命令工具安装在Linux终端中执行 安装gcc编译器： 1sudo apt install gcc 安装make命令工具： 1sudo apt install make 两个一路等待下载执行完成。 makefile的规则语法12目标（target）: 目标文件1 目标文件2 gcc -o 预建立的执行文件 目标文件1 目标文件2 注意：建立执行语法（也就是gcc那条语句）必须以tab键开头，不可以使用空格代替。 目标（target）就是我们想要建立的信息，而目标文件就是具有相关性的object files。 语法： 在makefile当中的#代表批注； tab键需要在命令行（例如gcc这个编译程序指令）的开头第一个字符； 目标（target）与相关目标文件之间需要用 : (分号)隔开； makefile使用举例说明我们要编译main.c、test1.h、test2.h、test3.h生成可执行程序TEST。 我们可以直接使用gcc这样写： 1gcc -o TEST main.c test1.h test2.h test3.h 但是就像上面说的，我们之后发现了test2.c里面的内容写错了，改好之后要重新编译，我们接着输入上面的命令进行编译。但是如果我们一个项目有很多文件时，就很麻烦了。我们可以写个makefile简化方便执行。 创建一个makefile或者Makefile文件（必须是），因为make指令在编译时它会查找以下文件是否有makefile或者Mkefile： 1touch makefile vi命令进入makefile： 1vi makefile 修改makefile文件如下： 12TEST： main.c test1.h test2.h test3.h gcc -o TEST main.c test1.h test2.h test3.h 我的main.c、test1.h、test2.h、test3.h内容如下： 一切准备完成之后，我们直接执行make即可编译文件： 1make 编译完成后，我们看到目录下产生了TEST文件，接下来执行它试试看： 1./TEST 如果不想让编译规则显示在屏幕上，只要在编译规则前面加个@。 如果现在再对文件编译一次会发生什么呢？可以试一下。 如果修改了其中一个文件再编译一下又会发生什么？ 现在我们在makefile里面定义一个clean，用来执行rm的操作： 1234TEST： main.c test1.h test2.h test3.h gcc -o TEST main.c test1.h test2.h test3.hclean: rm -f TEST 执行： 1make clean 这里调用了clean，就把之前编译完成的TEST文件删除了。 像我们有多个文件需要处理，可以在makefile里面定义一个变量： 12345OBJS = main.c test1.h test2.h test3.hTEST： $(OBJS) gcc -o TEST $(OBJS)clean: rm -f TEST 结果和上面写法一样，如果我们执行make clean TEST，先调用clean清除，然后调用了TEST编译。 注意： 变量名左边不可以加tab键； 变量与变量内容用 = （等号）隔开； 变量名最好大写，为了编码风格； 运用变量时，以$(变量名)或者${变量名}使用；]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
